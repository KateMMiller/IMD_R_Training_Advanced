---
author: "Kate Miller & Ellen Cheng"
date: "1/10/2022"
output: 
  html_document:
    css: custom_styles.css
---

```{r setup2, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Intro to R Markdown {.tabset}
<details open><summary class='drop'>Background</summary>
R Markdown is a special file format that you can open in RStudio (go to File > New File, and "R Markdown..." is the 3rd option). R Markdown takes what you put into the .Rmd file, knits the pieces together, and renders it into the format you specified using PanDoc, which is typically installed as part of the RStudio IDE bundle. The knit and render steps generally occur at the same time, and the terms are often used interchangeably. For example, the Knit button (<img src="./images/knit_button.png" alt="knit" width="70px">) knits and renders the .Rmd to your output file. The knit shortcut is also super handy, which is Ctrl + Shift + K. 

The most commonly used outputs are HTML, PDF, and Word. Each output format has pros and cons, and drives which text editing language (e.g., HTML or LaTeX) you need to use for advanced/custom needs. We'll cover these in more detail in a minute.
</details>
<br>
<details open><summary class='drop'>Reasons to use R Markdown</summary>
We're all busy and it's hard to keep up on everything we need to know to do our jobs well. We wouldn't be promoting R Markdown like we are, if we didn't feel that it was a huge contributor to our efficiency and productivity. R Markdown has been described as the Swiss Army knife of Data Science, because there are so many things you can do with it. Below are just a few of the many reasons we use R Markdown.
<ul>
<li>My favorite part of R Markdown is that it's one stop shopping to store code, text/notes, results, etc., as I'm working on an analysis and writing a report. It saves me the hassle of copying and pasting figures and tables from an analysis into Word or PowerPoint, and allows me to write notes as I'm analyzing. These notes often end up going right into the Methods and Results sections my papers.</li>
<li>They're reproducible and easily updated. If the data changes, or you realize there's an error in your analysis, all you have to do is fix the issue, then rerender the .Rmd to update the output file.</li>
<li>You can use parameters (e.g., park code, year, species) to iterate through and generate multiple separate reports for each unique parameter. We'll show examples of that later. </li>
<li>The learning curve is also very shallow at the outset. In about 5 minutes of playing with it, you'll get the basics of how it works. Then, as you learn more HTML/CSS or LaTeX, the sky is the limit. This website, in fact, is built from R Markdown and hosted as a GitPage for the <a href = "https://github.com/KateMMiller/IMD_R_Training_Advanced">repo that hosts the code</a>. </li>
</ul>
</details>
<br>
<details open><summary class='drop'>Getting Started</summary>
To get started, you'll need to make sure you have the `rmarkdown` package installed. The `knitr` package, which does a lot of heavy lifting, is a dependency of `rmarkdown`, so both will be installed with the line of code below.

```{r installmark, eval = F, echo = T, out.width="400px"}
install.packages("rmarkdown") 
```

Once you have `rmarkdown` installed, you should be able to go to <b>File > New File > R Markdown...</b>, and start a new .Rmd file. After selecting "R Markdown...", you will be taken to another window where you can add a title and author and choose the output format. For now, let's just use the default settings and output to HTML. You should now see an Untitled .Rmd file in your R session with some information already in the YAML and example plain text and code chunks. You can also start with a blank .Rmd, which will be more convenient once you get the hang of it. 

</details>
<br>
<br>
<hr>

#### Anatomy of an .Rmd 
<details open><summary class='drop'>YAML</summary>
The .Rmd file itself consists of 3 main pieces. There's the YAML (Yet Another Markup Language) code at the top, which is contained within `---`, like the image below. The top YAML is typically where you define features that apply to the whole document, like the output format, authors, parameters (more on that later), whether to add a table of contents, etc. The YAML below is what we're using for this website. Note that indenting is very important in YAML. The css: custom_styles.css tells Markdown that I want the styles defined in my css, rather than the default styling in Markdown. This is optional, and is here just to show a variation on the default YAML you get when starting a new .Rmd. If you don't want to use your own custom style sheet, then your YAML would just have the following in one line: `output: html_document`.

```{r yaml, echo=F, out.width = '300px', fig.align = "left", dpi=600}
#------------------
# R Markdown I
#------------------
knitr::include_graphics("./images/YAML.png")
```

- other common additions in YAML: headers/footers, table of contents, parameters

</details>
<br>

<details open><summary class='drop'>Plain text</summary>
This is what it sounds like- it's just text. You can write anything you want outside of a code chunk, and it will render as if you're writing in a word processor, rather than as code. Although, note that special characters like % and & may need to be escaped with a `/` before the symbol, particularly if you're using LaTeX (more on that later).
You can format text using Markdown's built in functions, like those shown below. For a more detailed list of these formatting functions, check out the <a href="https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">R Markdown Cheatsheet</a>. You can also code HTML directly in R Markdown, which I actually find easier the more I get comfortable with HTML. The section below shows how to use the same common styles with R Markdown and HTML and what the output looks like.

<div class = 'boxBorder'>
<div class = 'row'>
<div class = 'column3'>
The actual text in the .Rmd:
```{markdown, verbtxt, attr.source="style='display:inline-block;'", collapse=TRUE}
# First-level header

## Second-level header

...

###### Sixth-level header

*italic* or _italic_

**bold** or __bold__

superscript^2^

endash: --

Example sentence: *Picea rubens* is the dominant species in **Acadia National Park**.

```
</div>
<div class = 'column3'>
The HTML version:
```{html, verbhtml, attr.source="style='display:inline-block;'", collapse=TRUE}
<h1>First-level header</h1>

<h2>Second-level header</h2>

...

<h6>Sixth-level header</h6>

<i>italic</i>

<b>bold</b>

superscript<sup>2</sup>

endash: &ndash;

Example sentence: <i>Picea rubens</i> is the dominant species in <b>Acadia National Park</b>.

```
</div>
<div class = 'column3'>

The text renders as:

# First-level header <br>

## Second-level header <br>

...
<p style="padding-bottom:0;padding-top:10px">

###### Sixth-level header <br>
</p>
<p style="padding-bottom:0;padding-top:10px">
*italic* or _italic_ <br>
</p>
<p style="padding-bottom:0;padding-top:10px">
**bold** or __bold__ <br>
</p>
<p style="padding-bottom:0;padding-top:4px">
superscript^2^ <br>
</p>
<p style="padding-bottom:0;padding-top:8px">
endash: -- <br>
</p>
<p style="padding-bottom:0;padding-top:6px">
Example sentence: *Picea rubens* is the dominant species in **Acadia National Park**.<br>
</p>
</div>
<br>

</div></div>
</details>
<br>

<details open><summary class='drop'>Code chunks</summary>
Code chunks are also what they sound like. They're chunks of R code (can be of other coding languages too), which run like they're in an R script. They're contained within back ticks and curly brackets, like below. 

````
`r ''````{r}

```
````
<p style="color:white">
`````</p>

You can customize the behavior and output of a code chunk using options within the `{ }`. Common chunk options are below:
<ul>
<li>`echo = TRUE` prints the code chunk to the output. `FALSE` omits the code from output. </li>
<li>`results = 'hide'` omits results of code chunk from output. `show` is the default. </li>
<li>`include = FALSE` executes the code, but omits the code and results from the output. </li>
<li>`eval = FALSE` does not execute the code chunk, but can print the code, if `echo = TRUE`.</li>
<li>`cache = TRUE` allows you to cache the output associated with that code chunk, and will only rerun that chunk if the code inside the chunk changes. Note that if the objects or data in the code chunk are changed, but the code within the chunk is still the same, the code chunk won't realize that it needs to rerun. You need to be careful about using the cache option.</li>
<li>`fig.cap = "Caption text"` allows you to add a figure caption. </li>
<li>`fig.width = 4`; `fig.height = 3` allows you set the figure size in inches. </li>
<li>`out.width = 4`; `out.height = 3` allows you set the figure or table size as a percentage of the container/page size. </li>
<li>`message = FALSE, warning = FALSE` prevent messages or warnings from chatty packages from being included in the output. </li>
</ul>
<br>
See the <a href="https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">R Markdown Cheatsheet</a> for a complete list of code chunk options.
<br>
Another trick to using code chunk options, is that they can be conditional based on the results from another code chunk. For example, I have a QC report that runs 40+ checks on a week's worth of forest data, but the report only includes checks that returned at least 1 value/error. Checks that returned nothing are omitted from the report using conditional eval. I'll show an example of that later.

</details>
<br>
<hr>

#### Output types
For all of the output types, the built-in markdown functions, like '#' for level 1 header, render as you expect. Most output types also have an additional code base that allows more advanced and customized features. 

<details open><summary class='drop'>Output to HTML</summary>
The code base for HTML is obviously HTML and cascading style sheets (CSS). HTML is used to structure the content. CSS is used to define the style (eg font type and size for each header level). 

<h3>Pros of HTML output</h3>
1. Fewest dependencies and least finicky of the 3 main outputs (i.e., PDF and Word).
2. You can code straight HTML and CSS in your markdown document (javascript too), so you're not limited by the built-in functions in markdown or knitr that render R code as HTML. 
3. Easy to share, and usually renders well on the most common browsers.
4. Allows you to host your files as GitPages (like this training website).
5. Relatively easy to make 508 Compliant (but don't ask me how to do it).

<h3>Cons of HTML output</h3>
1. HTML files are hard to make print friendly. Page breaks aren't an easy thing to add, and headers with a filled background (i.e., NPS banner) are hard to make print as they appear on the screen. 
2. If you share an HTML with someone, they often have to download it first and then open it in their browser. The version MS Outlook or SharePoint shows when opened within the app has less functionality than a web browser. If you have anything even slightly fancy (i.e., tabs) the view from attachments won't look the same as through a browser (or just shows you the raw HTML). This means you always have to include these instructions when sharing HTML files. 
</details>
<br>
<details open><summary class='drop'>Output to PDF</summary>
Rendering to PDF requires a LaTeX engine that runs under the hood. The easiest engine to install is `tinytex`, and there are instructions and download files on the "Prep for Training" tab of this site.

<h3>Pros of PDF output</h3>
1. PDFs are a more familiar file format and easier to share (i.e., can be viewed directly in MS Outlook/SharePoint).
2. Enforcing page breaks and designing print friendly outputs is much easier than with HTML output.

<h3>Cons of PDF output</h3>
1. LaTeX is a challenging, clunky, and not overly rewarding coding language to work with. There are decent websites offering help and examples, but it's nothing like the help community and resources for HTML (or R).  
2. I'm no expert on LaTeX, so perhaps it just me. But I've spent hours fine-tuning a header in LaTeX that takes  minutes to figure out in HTML, only to have it break after updating a LaTeX package. If your output needs to be PDF, pause to think whether you REALLY need it to be PDF. If PDF is still what you want, you'll likely need to use at least some LaTeX along the way.  
3. It's much harder to make PDFs 508 Compliant using R Markdown. The functionality just isn't there, as far as I know. PDFs have to be modified after they're rendered to be 508 Compliant, which kind of defeats the purpose of automated reporting.
</details>
<br>
<details open><summary class='drop'>Output to Word</summary>
Rendering to Word can be a helpful way to generate a Results section for a report, or even the entire report for the first draft. It saves having to copy/paste figures and tables from R to Word, and makes life easier if you need to rerun your analysis or update a figure. You just update the .Rmd code and render again to Word. Admittedly I rarely use this option because the functionality is much more limited than outputting to PDF or HTML(See first Con below). For more details than we'll go into today, check out RStudio's article: <a href="https://rmarkdown.rstudio.com/articles_docx.html">Happy collaboration with Rmd to docx</a>.    

<h3>Pros of Word output</h3>
1. It's easy to import a word document with styles as a template, and then to output your document to Word.
2. Word documents are easy to share, and may be easier to collaborate with than a Markdown file (i.e. track changes in Word).
3. You can use a Reference Management System for bibliographies (although see bullet 3 in Cons).

<h3>Cons of Word output</h3>
1. This is the most limited output. You really can only apply the main styles in the template you imported. Figures and tables don't always render all that well, and often need to be tweaked again in Word. Headers and footers don't render either. It's possible the `officedown` package may add functionality, but I haven't played around with it enough (and the times I checked for a certain function, it didn't have it). 
2. Incorporating track changes back into R Markdown is a messy, manual process. It's not something you'd want to do repeatedly for the same paper.
3. I have yet to get a reference management system to work in Markdown. While it's possible, it may be hard to implement on government furnished equipment using approved software.
</details>
<br>

<details open><summary class='drop'>Other outputs</summary>
There are dozens of other types of output, including FlexTables/Dashboards, slide decks for presentations, and posters for scientific meetings. There are also templates for journal articles with certain journals, and even templates for building a CV or resume. RStudio's R Markdown page on <a href="https://rmarkdown.rstudio.com/lesson-9.html">Output Formats</a> includes a list with links to a bunch of other output templates. Others can be easily found and downloaded from online sources. 
</details>
<br>

#### Tables 
<details open><summary class='drop'>Tables in R Markdown</summary>
There are quite a few packages that can help you make publication quality and customized tables. The two tables I see used most frequently are `kable()` in the `knitr` package and `datatables()` in the `DT` package (not to be confused with `data.table()` package for data wrangling in R). The learning curve for kable is pretty shallow, and runs HTML under the hood. The learning curve for DT is a bit steeper, and has javascript under the hood. That means you can customize and add more features using those languages, if you know them. I tend to stick with kable, because I find HTML/CSS easier to code. If I need more bells and whistles, then I use datatables.

First, we'll load a fake wetland dataset on our GitHub repo to make some summary tables using each package. The code below downloads the dataset from the training GitHub repo, and then summarizes the number of invasive and protected species per site. For both examples, the output format is HTML. If I were outputting to PDF, then I'd need to specify the format as 'latex' and use LaTeX code for any custom features not built into kable. 
```{r importdat, echo = T, results = 'hide', warning = FALSE, message = FALSE}
library(tidyverse)
wetdat <- read.csv(
  "https://raw.githubusercontent.com/KateMMiller/IMD_R_Training_Advanced/main/data/ACAD_wetland_data_clean.csv")
wetsum <- wetdat %>% group_by(Site_Name, Year) %>% 
  summarize(num_inv = sum(Invasive), num_prot = sum(Protected), 
            .groups = 'drop')
```

</details>

<details open><summary class='drop'>kable and kableExtra</summary>
The code below creates a simple table that renders in HTML, is only as wide as the records in the table, and has alternating row colors. If you're outputting to PDF, your format will be "latex" instead of "HTML" and you'll need to use LaTeX for any custom formatting/styling that aren't built into kable and kableExtra.

Note also that the version of kableExtra on CRAN currently has a bug that causes `collapse_rows()` not to function. I'll show what this does in a minute, but for now, just know that if you want to collapse rows in your kable, you'll need to install the development version of kableExtra on GitHub. Code for that is below. You'll need the `devtools` package installed to install it. If you've already loaded `kableExtra` in your session, you'll also need to restart your session (Note: Ctrl + Shift + F10 is the fastest way to restart your R session).
<br>
```{r kab1, echo = T, results = 'hide', warning = FALSE, message = FALSE}
devtools::install_github("haozhu233/kableExtra")
library(kableExtra) # for extra kable features
library(knitr) # for kable
wet_kable <- kable(wetsum, format = 'html') %>% # if using pdf, need LaTeX
             kable_styling(full_width = FALSE, bootstrap_options = 'striped') #kableExtra function
wet_kable
```
```{r kab2, echo = F, results = 'show', results = 'asis'}
wet_kable
```
<br>
Note the use of pipes in the code above. The great thing about kable and kableExtra is that you can pipe functions together to build out a large table with all kinds of formatting, including conditional formatting. You can also make a custom kable function that has all of the formatting options you want, and just specify the dataset to build the table for. You can then pipe more features onto that function. We'll show a couple of these examples below.
<br>
```{r kab3, echo = T, results = 'hide'}
# custom kable function that requires data, column names and caption
make_kable <- function(data, colnames = NA, caption = NA){
  kab <- kable(data, format = 'html', col.names = colnames, align = 'c', caption = caption) %>% 
      kable_styling(fixed_thead = TRUE, 
                    bootstrap_options = c('condensed', 'bordered', 'striped'), 
                    full_width = FALSE, 
                    position = 'left', 
                    font_size = 12) %>%
      row_spec(0, extra_css = "border-top: 1px solid #000000; border-bottom: 1px solid #000000;") %>% 
      row_spec(nrow(data), extra_css = 'border-bottom: 1px solid #000000;')

}

# use function with wetsum data
wetkab2 <- make_kable(wetsum, 
                      colnames = c("Site", "Year", "# Invasive", "# Protected"),
                      caption = "Table 1. Summary of wetland data") %>% 
           scroll_box(height = "250px")
```
```{r kab4, echo = F, results = 'show'}
wetkab2
```
<br>
<br>
There are a couple of new things to point out in the code: 
<ol>
<li>Because we set the arguments for colnames and caption to default to `NA`, you don't have to specify them for the function. If you don't, the column names in the table will be the names in the dataframe, and the caption will be omitted. </li>
<li>We set the columns to be centered with `align = 'c'`. If you wanted the first column to be left, and the next 3 to be centered, you would write `align = c('l', rep('c', 3))`. </li>
<li>The fixed_thead = TRUE means that if a scroll bar is added to the table, the table header (top row), will be fixed. Here we piped a scroll_box at the end of the code to show how that works. You can add a scroll box to the width of the page by adding a `width = "###px"` to the argument. Note also that if you add a scroll box, you'll want that line of code to be last. Otherwise you're likely to run into weird issues with kable that prevent the table from rendering. This is why I piped it at the end, instead of adding to the function. </li>
<li>The position = 'left' left justifies the table on the page (default is center).</li>
<li>The line starting `row_spec(0, )` adds a black border to the top and bottom of the header, which kable considers row 0. </li>
<li>The final `row_spec(nrow(data))` is adding a black border to the bottom of the table regardless of the number of rows in the table.</li>
</ol>

<br>
Finally, here are a few helpful options that render based on values in the table. Note that because we added a scroll box to wetkab2, we'll start the code over, rather than add the features via pipe to wetkab2. The scroll box always needs to be the last call in your code. If it's not you'll get a cryptic error message about `Error in UseMethod("nodeset_apply")`.
<ul>
<li><b>Conditional formatting</b> was applied to column 3 in the table (wetsum$num_inv). In the code below, the `ifelse()` that ends in FALSE is just allowing the default color to be printed instead of the conditional color. That allows the alternating row colors to remain.</li>
<li><b>Collapsing rows</b> were applied to column 1. In the rendered table you should see that Sites that are repeated in the data are merged vertically in column 1. This is a really helpful feature to make tables more digestible. Note that once you collapse a row, all pipes afterwards subtract the row you collapsed from the table dimensions, and it can be tricky to deal with. In general, it's best to have the `collapse_rows()` pipe after any `column_spec()` or `row_spec()` calls. You can also collapse on multiple columns, but it is finicky about the order of the pipes. Just use trial and error until you find the order that works. Note also that `collapse_rows()` only works in the development version of the package (see above for installation instructions).</li> 
</ul>

```{r kab5, echo = T, results = 'hide'}
wetkab3 <- make_kable(wetsum, 
                      colnames = c("Site", "Year", "# Invasive", "# Protected"),
                      caption = "Table 1. Summary of wetland data") %>% 
           row_spec(0, extra_css = "border-top: 1px solid #000000; border-bottom: 1px solid #000000;") %>% 
           column_spec(3, background = ifelse(wetsum$num_inv > 0, "orange", FALSE)) %>% 
           collapse_rows(1, valign = 'top') 
```
```{r kab6, echo = F, results = 'show'}
wetkab3
```
</details>

<details open><summary class='drop'>DT::datatables</summary>
Using the same wetsum dataset we created earlier, we'll make a table using `datatable()` and will add some of the features that `kable()` doesn't have and that usually lead me to choose datatable over kable. We'll start with a basic example and build on it.

```{r dt1, echo = T, results = 'hide'}
library(DT)
wetdt <- datatable(wetsum, colnames = c("Site", "Year", "# Invasive", "# Protected"))
wetdt
```
```{r dt2, echo = F, results = 'show'}
wetdt
```

The resulting table has several nice features that kable doesn't offer.
<ul>
<li>The search box allows you to search the records in the text </li>
<li>Each column can be sorted using the arrows to the right of each column name </li>
<li>Vertical scroll bars are added by default, and only a subset of rows are displayed. </li>
</ul>

If you want to show more or less entries in your table at a time, you can specify different values by adding options and then specifying values either for `pageLength`, or for `lengthMenu`. The `pageLength` option takes 1 value and will then display that number of entries in the table. The `lengthMenu` is similar, but also allows you to add multiple values to this list, which are then added to the dropdown menu in the Show [##] entries box. That allows the user to select the number of entries they want to see at a time.

I also added an option that stops the table from spanning the entire page.
```{r dt3, echo = T, results = 'hide'}
# modify pageLength and lengthMenu
wetdt2 <- datatable(wetsum, colnames = c("Site", "Year", "# Invasive", "# Protected"),
                    width = "40%",
                    options = list(pageLength = 10,
                                   lengthMenu = c(5, 10, 20))
                    )

```
<br>
```{r dt4, echo = F, results = 'show'}
wetdt2

```
<br>

Several additional features with datatable are shown in the code below. 
<ul>
<li>CSS can be specified in the table. Here we added a cell-border stripe, which adds vertical lines between columns the same way `bootstrap_options` added striped cells in kable.</li> 
<li>Filtering by one or more columns in the table can be really handy. This is often the reason I end up using datatable instead of kable. The code below adds a filter to the top of the columns in the table. This is a particularly useful feature if your tables have a lot of rows.</li>
<li>Allowing data to be editable is also potentially really useful. For example, you can add a blank Notes column that can then be updated and saved in the table. In the code below, I made the Notes column editable at the cell-level. Note that you have to double-click on the row to edit it. Just beware that adding notes to tables in R Markdown can cause some strange behaviors with tabs. </li>
<li>Piping the formatStyle at the end allows us to set conditional formatting like we did for cable, where any value > 0 in the 3rd column will be orange.</li>
</ul>
<div>
```{r dt5, echo = T, results = 'hide'}
wetdt3 <- datatable(data.frame(wetsum, "Notes" = NA), 
                    width = "40%",
                    colnames = c("Site", "Year", "# Invasive", "# Protected", "Notes"),
                    options = list(pageLength = 10),                        
                    class = 'cell-border stripe',
                    filter = list(position = c('top'), clear = FALSE),
                    editable = list(target = 'cell', disable = list(columns = 1:4))) %>% 
          formatStyle(3, backgroundColor = styleInterval(0, c('white', "orange")))
wetdt3

```
```{r dt6, echo = F, results = 'show'}
wetdt3
```
</div>


</details>

#### Figures
- images 
- figure captions and numbering

#### Examples
- QA/QC report and weekly checking (html)
- Regen analysis or invasive analysis (html)
- NPS template and MIDN report (docx)
- Ellen's COVID reports (pdf)

#### Bells and Whistles
- parameters
- iterating knitr text into tabs
- conditional eval = obj or include = obj
- tabsets
- html widgets and interactives (plotly?, crosstable?)
- Show example of rendering a bunch of markdown docs (e.g. one for each park)

#### Resources
<h3>R Markdown</h3>
<a href="https://bookdown.org/yihui/rmarkdown/">R Markdown: The Definitive Guide</a>. This is Yihui Xie's book that's available free online and for purchase. Yihui is one of the main developers at RStudio working on R Markdown and related packages (e.g. knitr, pagedown, bookdown). The online book is searchable, and is often the first place I check, when I can't remember how to do something.
<br>
<a href="https://r4ds.had.co.nz/">R for Data Science</a>, chapters 27 and 29. The book itself is worth a read cover to cover. The chapters on R Markdown are also very helpful on their own.
<br>
<a href="https://rmarkdown.rstudio.com/">RStudio's R Markdown page:</a> Includes several short videos and lots of tutorials, articles, and a gallery to give an idea of the many things you can do.

<a href="https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">R Markdown Cheat Sheet</a>.

<a href="https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html">kableExtra vignette:</a> Lots of great examples of the different styling/formats you can use with kables and the kableExtra package.

<h3>HTML/CSS</h3>
<a href="https://www.w3schools.com/html/default.asp">W3 Schools HTML page:</a> This website includes helpful tutorials on HTML and CSS, includes executable examples for just about every HTML tag you can think of, and shows how different browsers render content.
<br>
<a href="https://www.htmlandcssbook.com/">HTML & CSS design and build websites:</a> This book costs about $15 (cheaper if you can find a used copy) and was a very helpful introduction and continual resource, particularly for working with CSS. There's a Javascript & JQuery book by the same author that's equally well-done, but was a much steeper learning curve.

<h3>LaTeX</h3>
<a href="https://ctan.org/">CTAN.org:</a> This is LaTeX's version of CRAN. 
<br>
<a href="https:/www.overleaf.com/learn">Overleaf Online LaTex Editor:</a> Includes a short guide to learn LaTeX, examples for most common uses of LaTeX, and has a built in editor that you can excecute code in.

````
<hr>